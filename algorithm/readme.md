# 算法技巧大全

## 代码套路

### 数据结构的遍历

如何遍历 + 访问？ 我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。
线性就是 for/while 迭代为代表，非线性就是递归为代表。
再具体一步，无非以下几种框架：

1. 数组遍历框架（典型的线性迭代结构）

``` cpp
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        // 迭代访问 arr[i]
    }
}
```

2. 链表遍历框架（兼具迭代和递归结构）

``` cpp
/* 基本的单链表节点 */
class ListNode {
    int val;
    ListNode next;
}

void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {
        // 迭代访问 p.val
    }
}

void traverse(ListNode head) {
    // 递归访问 head.val
    traverse(head.next)
}
```

3. 二叉树遍历框架（典型的非线性递归遍历结构）

二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。
如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。

``` cpp
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    // root 需要做什么？在这做。
    // 其他的不用 root 操心，抛给框架
    traverse(root.left)
    traverse(root.right)
}
```

4. 针对BST的遍历框架
   
``` cpp
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

5. 二叉树框架可以扩展为 N 叉树的遍历框架

``` cpp
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}

void traverse(TreeNode root) {
    for (TreeNode child : root.children)
        traverse(child)
}
```

### 动态规划框架

动态规划的三个需要明确的点就是「状态」「选择」和「base case」

```cpp
    for (状态 ：状态集合)
        for （选择 in 选择列表）
            dp[状态] = func(选择1， 选择...)

```

### 回溯算法框架

``` python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

### 二分查找框架 

搜索边界

``` cpp
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

### 滑动窗口框架

子串问题，经常使用

```cpp
int left = 0, right = 0;

while (right < s.size()) {
    window.add(s[right]);
    right++;
    while (valid) {
        window.remove(s[left]);
        left++;
    }
}
```

## 一些经典问题：

1. 偏序问题

偏序基本思想有：树套树（代码量较大、不想写qaq）、CDQ分治。
https://www.bbsmax.com/A/rV57b329JP/

2. 

----------------------------

## 一些算法设计技巧
#启发式思考！



对于同一个问题，如果有多种解法，那么全部找出来！

如果好几个问题，他们貌似有共同之处，那么找出来
*侧重点：抽象思维*

共同之处在于，可能他们使用了：
相同的技巧：

对撞指针：
思想：对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。
潜在场景：对撞数组适用于有序数组，也就是说当你遇到题目给定有序数组时，应该第一时间想到用对撞指针解题
举例
1. Sum of Square Numbers
2. 两（三）数之和问题
3. 快排分区

快满指针：
思想：快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。
潜在场景：链表
举例：
    和为S的连续正数序列
    链表中是否有环
    链表倒数K个数
    链表环的开始位置

滑动窗口（也是一种特殊的双指针）
思想：
潜在场景：
举例：

常规双指针：
    有序合并

某种思想
回溯思想，https://www.cnblogs.com/blogtech/p/12295484.html
分治思想
    尤其是二分
减治思想

某种算法策略

某个经典问题

二分查找以及一系列变种 https://www.cnblogs.com/luoxn28/p/5767571.html

https://www.cnblogs.com/sdlwlxf/p/5131793.html


## 每日一战 3.29

### 动态规划

股票最大利润问题

第一，使用动态规划算法之前，一般考虑两个基本问题：

1. 定义何种数组来表示各个阶段的状态
dp[i][0] 表示前 i 天，没有持有股票状态下的大利润；
dp[i][1] 表示前 i 天，持有股票状态下的最大利润
2. 如何通过前阶段已有的状态，推出现阶段的状态
考虑dp[i][0], 前i-1天已经完成了买卖；或者前i-1买入了（买入价格怎么得知），i天卖出
考虑dp[i][1], 前i-1天买入了股票；或者i天买入了股票，此时最大利润是啥？
第二，考虑是否可以进行空间上的优化
通过状态转移方程，我们可以看出，现阶段状态只和前一阶段的状态有关，因此我们并不需要定义数组来记录每一个阶段的状态。

LIS
dp[i]表示以a[i]结尾的最长递增子序列长度
d(i) = max{ 1,  d(j)+1} ,且满足当i > j时，A[i] >= A[j] 

### 回溯

全排列问题

回溯的定义：
回溯，又称回溯搜索算法，主要用于在一个庞大的空间里搜索我们所需要的问题的解。
回溯的本质：
回溯”指的是“状态重置”，可以理解为“回到过去”、“恢复现场”，是在编码的过程中，是为了节约空间而使用的一种技巧。而回溯其实是“深度优先遍历”特有的一种现象。之所以是“深度优先遍历”，是因为我们要解决的问题通常是在一棵树上完成的，在这棵树上搜索需要的答案，一般使用深度优先遍历。
回溯框架：


使用回溯算法之前，一般考虑的几个问题：

1. 如何定义一个合适的解： 子集树、还是排列树
2. 考虑约束或者边界

子集、排列、组合

### 分治

最大子序和问题

考虑两个子问题：

1. 如何分割问题（常规的二分法）
2. 如何归并问题 (left_sum; right_sum; cross_sum)

### 贪心

股票买卖问题
波谷波峰交易法
区间问题：
    我们解决区间问题的一般思路是先排序，然后观察规律。
区间调度问题 
    最大不重叠子集，按照end排序
    区间合并，按照start/end排序都可以
    区间交集

``` python
# A, B 形如 [[0,2],[5,10]...]
def intervalIntersection(A, B):
    i, j = 0, 0 # 双指针
    res = []
    while i < len(A) and j < len(B):
        a1, a2 = A[i][0], A[i][1]
        b1, b2 = B[j][0], B[j][1]
        # 两个区间存在交集
        if b2 >= a1 and a2 >= b1:
            # 计算出交集，加入 res
            res.append([max(a1, b1), min(a2, b2)])
        # 指针前进
        if b2 < a2: j += 1
        else:       i += 1
    return res
```


### 双指针

盛最多水的容器 对碰指针

### 滑动窗口

滑动窗口最大值
双端队列



### 栈的妙用

主要是单调栈
NextGreaterNext

### 队列的妙用

主要是单调队列
滑动窗口Ma问题

### 双指针的妙用

接雨水问题

### 滑动窗口的妙用

字符串匹配问题



数据结构是工具，算法是通过合适的工具解决特定问题的方法.

你就会发现只要涉及递归的问题，都是树的问题。
动态规划： 换零钱问题
回溯算法：就是个 N 叉树的前后序遍历问题，没有例外。N皇后问题

动态规划问题的一般形式就是求最值。
求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。
首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。

明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。

先确定「状态」，也就是原问题和子问题中变化的变量。
然后确定 dp 函数的定义
然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当前状态。
最后明确 base case，

计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。

列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。

备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？


最优子结构：
全班最大值，全校最大值

那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题。

关于遍历方向：
1、遍历的过程中，所需的状态必须是已经计算出来的。
2、遍历的终点必须是存储结果的那个位置。

双指针问题

我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。

快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。

左右指针的常用算法
左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 

有序数组/链表去除重复

子序列判定问题

可能还会问，这里只求出了最小的编辑距离，那具体的操作是什么？你之前举的修改公众号文章的例子，只有一个最小编辑距离肯定不够，还得知道具体怎么修改才行。
这个其实很简单，代码稍加修改，给 dp 数组增加额外的信息即可。

最小编辑距离
LIS

前缀和技巧
前缀和数组， 计算[i,j]的和，空间换时间
前缀和不难，却很有用，主要用于处理数组区间的问题。


单调队列
滑动窗口最大值


算法关键字：
循环数组

mod操作，假设有两个一样的数组拼一起；

前缀和
1. 求解连续和为k

单调栈
定义：单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。
单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。

单调递减栈，栈顶元素最小
一般套路:
如果找右边更大的元素，则从前到后构造递减栈;
如果找右边更小的元素，则从前到后构造递增栈;
如果找左边更大的元素，则从后到前构造递减栈;
如果找左边更小的元素，则从后到前构造递增栈;
举一个例子: 右边比我更大的问题
栈里面存的是啥？
存的是还没有算出来的元素，为啥没有算出来呢，因为还没有遇到比栈顶元素更大的。并且栈顶元素是最小的，所以当前元素也不会大于栈里面的其他元素。
什么时候可以算出来？
后面遇到比栈顶更大的元素，这时候就出栈，并更新数据。
遍历到最后，栈里面还有啥内容？
整个列表中没有比这些元素更大的元素。

``` cpp
vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> ans(nums.size()); // 存放答案的数组
    stack<int> s;
    for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放
        while (!s.empty() && s.top() <= nums[i]) { // 判定个子高矮
            s.pop(); // 矮个起开，反正也被挡着了。。。
        }
        ans[i] = s.empty() ? -1 : s.top(); // 这个元素身后的第一个高个
        s.push(nums[i]); // 进队，接受之后的身高判定吧！
    }
    return ans;
}
```

单调队列
用途：可以解决滑动窗口的一系列问题

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    MonotonicQueue window;
    vector<int> res;
    for (int i = 0; i < nums.size(); i++) {
        if (i < k - 1) { //先把窗口的前 k - 1 填满
            window.push(nums[i]);
        } else { // 窗口开始向前滑动
            window.push(nums[i]);
            res.push_back(window.max());
            window.pop(nums[i - k + 1]);
            // nums[i - k + 1] 就是窗口最后的元素
        }
    }
    return res;
}
```

烙饼排序
经典递归


FloodFill
用途：二维矩阵搜索问题
本质：四叉树遍历问题

```cpp
// (x, y) 为坐标位置
void fill(int x, int y) {
    fill(x - 1, y); // 上
    fill(x + 1, y); // 下
    fill(x, y - 1); // 左
    fill(x, y + 1); // 右
}
```

xxxx
CDQ分治

我大致讲一下: 首先排序使x有序，然后进行CDQ分治，其基本还是和二维偏序时操作一样，但是在整体合并的处理上，不是直接查找，而是以y的顺序插入到树状数组当中，然后以t查找。

这是大致思维
更高维的偏序问题我未接触过，但是应该和我上述一样，升维即可，树套树，CDQ套CDQ等等…

递归是一种编程技巧，一种解决问题的思维方式；分治算法和动态规划很大程度上是递归思想基础上的（虽然动态规划的最终版本大都不是递归了，但解题思想还是离不开递归），解决更具体问题的两类算法思想；贪心算法是动态规划算法的一个子集，可以更高效解决一部分更特殊的问题。
递推的思维是正常人的思维，总是看着眼前的问题思考对策，解决问题是将来时；递归的思维，逼迫我们倒着思考，看到问题的尽头，把解决问题的过程看做过去时。
明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。

回文串问题
核心思想：解决该类问题的核心是双指针

```cpp
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    找到以 s[i] 和 s[i+1] 为中心的回文串
    更新答案
```

该算法的名字叫 Manacher's Algorithm

概率问题

洗牌算法
基于交换

Fisher–Yates 洗牌算法
随机选K个：随机抽取 k 个元素，等价于对所有元素洗牌，然后选取前 k 个。
只不过，洗牌算法需要对元素的随机访问，所以只能对数组这类支持随机存储的数据结构有效。

蓄水池算法 k/i的概率被选择

TODO 优化的算法基于几何分布（geometric distribution），时间复杂度为 O(k + klog(n/k))。

给每一个元素关联一个随机数，然后把每个元素插入一个容量为 k 的二叉堆（优先级队列）按照配对的随机数进行排序，
最后剩下的 k 个元素也是随机的。
这种思路可以指导我们解决加权随机抽样算法，权重越高，被随机选中的概率相应增大，这种情况在现实生活中是很常见的，比如你不往游戏里充钱，就永远抽不到皮肤。

加权随机抽样问题

但凡遇到在动态过程中取最值的要求，肯定要使用有序数据结构，我们常用的数据结构就是二叉堆和平衡二叉搜索树了。
哨兵思维：
一个常用的编程技巧，就是使用一个「虚拟线段」让算法正确启动，这就和链表相关的算法需要「虚拟头结点」一个道理。

unionFind
数组实现 a[i] = parent;
通过size来平衡，优化到lgn

```cpp
class UF {
    // 连通分量个数
    private int count;
    // 存储一棵树
    private int[] parent;
    // 记录树的“重量”
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        
        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
```

并查集能能干什么？
DFS 的替代方案
很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决

另外，将二维数组映射到一维数组，
利用方向数组 d 来简化代码量，都是在写算法时常用的一些小技巧，如果没见过可以注意一下。

koro吃香蕉问题：

注意这个 for 循环，就是在连续的空间线性搜索，这就是二分查找可以发挥作用的标志

子序列判定问题， 二分查找优化

for (int i = 0; i < n; i++)
    if (isOK(i))
        return ans;